export enum Operator {
  Access = 'Access',
  And = 'And',
  Biconditional = 'Biconditional',
  Difference = 'Difference',
  Equality = 'Equality',
  Exponentiation = 'Exponentiation',
  Extends = 'Extends',
  Implication = 'Implication',
  Mod = 'Mod',
  Named = 'Named',
  Not = 'Not',
  Other = 'Other',
  Or = 'Or',
  Order = 'Order',
  Pipeline = 'Pipeline',
  Product = 'Product',
  Sum = 'Sum',
}

export enum Prec {
  Group = -1,
  SubtractionType = -1,
  UnionType = 0,
  Assignment = 1,
  TypeHint = 1,
  CurriedType = 1,
  NamedInfixApplication = 1,
  SectionIdentifier = 1,
  Literal = 1,
  IntersectionType = 1,
  LabeledType = 2,
  OperatorInfixApplication = 2,
  Extends = 3,
  OptionalType = 3,
  Biconditional = 4,
  TaggedType = 4,
  Implication = 5,
  Difference = 6,
  Or = 7,
  And = 8,
  Equality = 9,
  Order = 10,
  Mod = 11,
  Sum = 12,
  Product = 13,
  Exponentiation = 14,
  Not = 15,
  InfixApplication = 16,
  Application = 17,
  Term = 18,
  Pattern = 18,
  Access = 19,
  Pipeline = 20,
  // ParametricTypeInstance = 21,
  Argument = 21,
  // Hole = 21,
}

export const precedences = <RuleName extends string>(
  $: GrammarSymbols<RuleName>,
) => [
  [
    $.argument,
    Operator.Pipeline,
    'access',
    'patternOrTerm',
    'application',
    $.infix_application,
    Operator.Not,
    Operator.Exponentiation,
    Operator.Product,
    Operator.Sum,
    Operator.Mod,
    Operator.Order,
    Operator.Equality,
    Operator.And,
    Operator.Or,
    Operator.Difference,
    Operator.Implication,
    Operator.Biconditional,
    Operator.Extends,
    Operator.Other,
    Operator.Named,
    $._section_identifier,
    'base',
    $.group,
  ],
  // [
  //   Operator.Access,
  //   Operator.Pipeline,
  //   $.application,
  //   $.infix_application,
  //   Operator.Not,
  //   Operator.Exponentiation,
  //   Operator.Product,
  //   Operator.Sum,
  //   Operator.Mod,
  //   Operator.Order,
  //   Operator.Equality,
  //   Operator.And,
  //   Operator.Or,
  //   Operator.Difference,
  //   Operator.Implication,
  //   Operator.Biconditional,
  //   Operator.Other,
  //   Operator.Named,
  // ],

  // [$.assignment, $._term,
  //   Operator.Pipeline,
  //   Operator.Access,
  //   $.application,
  //   Operator.Not,
  //   Operator.Exponentiation,
  //   Operator.Product,
  //   Operator.Sum,
  //   Operator.Mod,
  //   Operator.Order,
  //   Operator.Equality,
  //   Operator.And,
  //   Operator.Or,
  //   Operator.Difference,
  //   Operator.Implication,
  //   Operator.Biconditional,
  //   Operator.Other,
  //   Operator.Named,
  //   $.static_application, $.group],

  // _term () :: application
  [$.application, $.tuple],

  // ? identifer :: hole
  [$.hole, $._term],
  // [$.hole, $.destructuring_pattern],
  // [$.hole, $.root_binding_pattern],

  // _term [ _term ] :: access
  // [$.access, $._element],

  // _term -> identifier :: access
  // [$.access, $._term],

  // { [ _term ] ... :: member
  [$.member, $._element],

  // _term ( ... binding_pattern ) = :: member
  // [$.tuple_pattern, $.application],

  // { identifier , ... :: struct
  [$.struct, $.binding_pattern],

  // _term ? _term ... :: conditional
  [$.conditional, $.optional_type],

  // type = _term :: binding_pattern
  [$.binding_pattern, $.infix_application],
  [$.binding_pattern, $.application],
]
