/// <reference types="tree-sitter-cli/dsl" />

import {
  _assignable_pattern,
  _literal_pattern,
  _pattern,
  binding_pattern,
  destructuring_pattern,
  list_pattern,
  member_pattern,
  pattern_group,
  root_binding_pattern,
  struct_pattern,
  tag_pattern,
  tuple_pattern,
  wildcard_pattern,
} from '../common/patterns'
import {
  _literal,
  boolean,
  decimal,
  escape_sequence,
  integer,
  interpolation,
  raw_string,
  regex,
  regex_flags,
  regex_pattern,
  string,
} from '../common/literals'
import {
  _element,
  _identifier_without_operators,
  _immediate_block,
  _operator,
  _section,
  _section_identifier,
  _statement,
  _term,
  access,
  application,
  argument,
  assignment,
  block,
  case_,
  class_,
  class_member,
  conditional,
  data,
  export_,
  function_,
  function_type,
  generator,
  group,
  hole,
  identifier,
  infix_application,
  instance,
  keyof_type,
  left_section,
  list,
  list_comprehension,
  map_type,
  member,
  optional_type,
  pure,
  return_,
  right_section,
  spread,
  static_application,
  static_function,
  struct,
  tag,
  tuple,
  type,
  type_hint,
  when,
  _arguments,
  _parameters,
} from '../common/terms'
import {
  _import_body_constructor,
  exported_import,
  import_,
  import_identifier,
  import_type,
} from '../common/imports'
import { comment, hash_bang_line } from '../common/miscellaneous'
import { Dialect } from '../common/dialects'
import { precedences } from '../common/precedences'

const dialect = Dialect.Tony

export = grammar({
  name: 'tony',

  externals: ($) => [
    $._newline,
    $._string_start,
    $._string_content,
    $._string_end,
  ],

  extras: ($) => [$.comment, /\s/],

  word: ($) => $._identifier_without_operators,

  conflicts: ($) => [
    [$._term, $.destructuring_pattern],

    [$.binding_pattern],
    [$._term, $.binding_pattern],
    [$.root_binding_pattern],
    [$._term, $.root_binding_pattern],
    [$.binding_pattern, $.root_binding_pattern],
    [$._term, $.binding_pattern, $.root_binding_pattern],

    [$.member, $.binding_pattern],
    [$.member, $.class_member],
    [$.member, $.class_member, $.binding_pattern],

    [$.list, $.list_pattern],
    [$.struct, $.struct_pattern],
    [$.tuple, $.tuple_pattern],
    [$._literal, $._literal_pattern],

    [$.tuple, $._arguments],
    [$.tuple_pattern, $._parameters],

    [$.raw_string, $.string],

    [$.group, $._element],
    [$.argument, $.tuple],

    // investigate
    [$.static_application, $.infix_application],
    [$.static_application, $.infix_application, $.conditional],
    [$._term, $.struct],
    [$._term, $.struct, $.binding_pattern],
    [$.import_type, $.binding_pattern],
    [$.import_identifier, $.binding_pattern],

    [$._term, $.hole, $.destructuring_pattern],
    [$._term, $.hole, $.root_binding_pattern],
    [$.tuple_pattern, $.application],
    [$.tuple_pattern, $.tuple, $.application],

    [$.infix_application, $.application],
    [$.infix_application, $.application, $.static_application],
    [$.infix_application, $.application, $.static_application, $.conditional],
    [
      $.infix_application,
      $.application,
      $.static_application,
      $.conditional,
      $.optional_type,
    ],

    [$.access, $._element],
    [$.access, $._term],
  ],

  precedences,

  rules: {
    program: ($) =>
      seq(
        optional(seq(field('hashBangLine', $.hash_bang_line), $._newline)),
        repeat(
          seq(field('import', choice($.import, $.exported_import)), $._newline),
        ),
        repeat(seq(field('term', $._statement), $._newline)),
      ),

    hash_bang_line,
    comment,

    import: import_,
    exported_import,
    _import_body: _import_body_constructor(dialect),
    import_identifier,
    import_type,

    _statement,
    _term,
    block,
    export: export_,
    assignment,
    class: class_,
    class_member,
    instance,
    argument,
    _parameters,
    function: function_,
    _arguments,
    application,
    infix_application,
    _section,
    left_section,
    right_section,
    _section_identifier,
    list_comprehension,
    generator,
    access,
    return: return_,
    static_application,
    static_function,
    conditional,
    _immediate_block,
    case: case_,
    when,
    struct,
    member,
    tuple,
    list,
    _element,
    spread,
    pure,
    hole,
    type_hint,
    data,
    tag,
    function_type,
    optional_type,
    keyof_type,
    map_type,
    type,
    _identifier_without_operators,
    _operator,
    identifier,
    group,

    _pattern,
    _assignable_pattern,
    destructuring_pattern,
    struct_pattern,
    tuple_pattern,
    list_pattern,
    member_pattern,
    binding_pattern,
    root_binding_pattern,
    wildcard_pattern,
    tag_pattern,
    _literal_pattern,
    pattern_group,

    _literal,
    boolean,
    decimal,
    integer,
    raw_string,
    string,
    interpolation,
    escape_sequence,
    regex,
    regex_pattern,
    regex_flags,
  },
})
