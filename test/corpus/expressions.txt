==================
abstraction
==================

(a) =>
  a
(a, b) => a
(a :: Type, b :: Type, 1, { c :: Type = 1 }) => a

fib :=
  (0) =>
    0
  (1) => 1
  (n :: Type = 2) =>
    fib(n - 1) + fib(n - 2)

(...a :: Type) =>
  b := (c :: Type) =>
    c
  b(1)

() => 1
/ := (a, b) => /

---

(program
  expression: (abstraction
    branch: (abstraction_branch
      parameters: (tuple_pattern
        value: (identifier_pattern
          name: (identifier_pattern_name)))
      body: (block
        expression: (identifier))))
  expression: (abstraction
    branch: (abstraction_branch
      parameters: (tuple_pattern
        value: (identifier_pattern
          name: (identifier_pattern_name))
        value: (identifier_pattern
          name: (identifier_pattern_name)))
      body: (block
        expression: (identifier))))
  expression: (abstraction
    branch: (abstraction_branch
      parameters: (tuple_pattern
        value: (identifier_pattern
          name: (identifier_pattern_name)
          type: (parametric_type
            name: (type)))
        value: (identifier_pattern
          name: (identifier_pattern_name)
          type: (parametric_type
            name: (type)))
        value: (number)
        value: (struct_pattern
          member: (shorthand_member_pattern
            name: (identifier_pattern_name)
            type: (parametric_type
              name: (type))
            default: (number))))
      body: (block
        expression: (identifier))))
  expression: (assignment
    pattern: (identifier_pattern
      name: (identifier_pattern_name))
    value: (abstraction
      branch: (abstraction_branch
        parameters: (tuple_pattern
          value: (number))
        body: (block
          expression: (number)))
      branch: (abstraction_branch
        parameters: (tuple_pattern
          value: (number))
        body: (block
          expression: (number)))
      branch: (abstraction_branch
        parameters: (tuple_pattern
          value: (identifier_pattern
            name: (identifier_pattern_name)
            type: (parametric_type
              name: (type))
            default: (number)))
        body: (block
          expression: (infix_application
            left: (application
              name: (identifier)
              value: (tuple_element
                value: (infix_application
                  left: (identifier)
                  name: (identifier)
                  right: (number))))
            name: (identifier)
            right: (application
              name: (identifier)
              value: (tuple_element
                value: (infix_application
                  left: (identifier)
                  name: (identifier)
                  right: (number)))))))))
  expression: (abstraction
    branch: (abstraction_branch
      parameters: (tuple_pattern
        rest: (rest
          name: (identifier_pattern
            name: (identifier_pattern_name)
            type: (parametric_type
              name: (type)))))
      body: (block
        expression: (assignment
          pattern: (identifier_pattern
            name: (identifier_pattern_name))
          value: (abstraction
            branch: (abstraction_branch
              parameters: (tuple_pattern
                value: (identifier_pattern
                  name: (identifier_pattern_name)
                  type: (parametric_type
                    name: (type))))
              body: (block
                expression: (identifier)))))
        expression: (application
          name: (identifier)
          value: (tuple_element
            value: (number))))))
  expression: (abstraction
    branch: (abstraction_branch
      parameters: (tuple_pattern)
      body: (block
        expression: (number))))
  expression: (assignment
    pattern: (identifier_pattern
      name: (identifier_pattern_name))
    value: (abstraction
      branch: (abstraction_branch
        parameters: (tuple_pattern
          value: (identifier_pattern
            name: (identifier_pattern_name))
          value: (identifier_pattern
            name: (identifier_pattern_name)))
        body: (block
          expression: (identifier))))))

==================
application
==================

a(1)(1, 2)
+(1)
a(?, 1)
+ 1
1 `a` -b()
a(...(a, b))

---

(program
  expression: (application
    name: (application
      name: (identifier)
      value: (tuple_element
        value: (number)))
    value: (tuple_element
      value: (number))
    value: (tuple_element
      value: (number)))
  expression: (prefix_application
    name: (identifier)
    value: (group
      value: (number)))
  expression: (application
    name: (identifier)
    value: (tuple_element)
    value: (tuple_element
      value: (number)))
  expression: (prefix_application
    name: (identifier)
    value: (number))
  expression: (infix_application
    left: (number)
    name: (identifier)
    right: (prefix_application
      name: (identifier)
      value: (application
        name: (identifier))))
  expression: (application
    name: (identifier)
    value: (tuple_element
      value: (spread
        value: (tuple
          value: (tuple_element
            value: (identifier))
          value: (tuple_element
            value: (identifier)))))))

==================
prefix application
==================

!false
+1
-1
~1

---

(program
  expression: (prefix_application
    name: (identifier)
    value: (boolean))
  expression: (prefix_application
    name: (identifier)
    value: (number))
  expression: (prefix_application
    name: (identifier)
    value: (number))
  expression: (prefix_application
    name: (identifier)
    value: (number)))

==================
infix application
==================

1 .. 1
1 ^ 1
1 * 1
1 / 1
1 + 1
1 - 1
1 % 1
1 < 1
1 <= 1
1 > 1
1 >= 1
1 == 1
1 != 1
a === 1
1 !== b
a ~ b
false && false
false || false
false ==> true <=> true
false && false || false
false || false && false
1 + 1 % 1
1 - 1 + 1
1 - -1
1 * 1 / 1 - 1
false || !false
(a.b) . c ^ 1 . (d.e)

---

(program
  expression: (infix_application
    left: (number)
    name: (identifier)
    right: (number))
  expression: (infix_application
    left: (number)
    name: (identifier)
    right: (number))
  expression: (infix_application
    left: (number)
    name: (identifier)
    right: (number))
  expression: (infix_application
    left: (number)
    name: (identifier)
    right: (number))
  expression: (infix_application
    left: (number)
    name: (identifier)
    right: (number))
  expression: (infix_application
    left: (number)
    name: (identifier)
    right: (number))
  expression: (infix_application
    left: (number)
    name: (identifier)
    right: (number))
  expression: (infix_application
    left: (number)
    name: (identifier)
    right: (number))
  expression: (infix_application
    left: (number)
    name: (identifier)
    right: (number))
  expression: (infix_application
    left: (number)
    name: (identifier)
    right: (number))
  expression: (infix_application
    left: (number)
    name: (identifier)
    right: (number))
  expression: (infix_application
    left: (number)
    name: (identifier)
    right: (number))
  expression: (infix_application
    left: (number)
    name: (identifier)
    right: (number))
  expression: (infix_application
    left: (identifier)
    name: (identifier)
    right: (number))
  expression: (infix_application
    left: (number)
    name: (identifier)
    right: (identifier))
  expression: (infix_application
    left: (identifier)
    name: (identifier)
    right: (identifier))
  expression: (infix_application
    left: (boolean)
    name: (identifier)
    right: (boolean))
  expression: (infix_application
    left: (boolean)
    name: (identifier)
    right: (boolean))
  expression: (infix_application
    left: (infix_application
      left: (boolean)
      name: (identifier)
      right: (boolean))
    name: (identifier)
    right: (boolean))
  expression: (infix_application
    left: (infix_application
      left: (boolean)
      name: (identifier)
      right: (boolean))
    name: (identifier)
    right: (boolean))
  expression: (infix_application
    left: (boolean)
    name: (identifier)
    right: (infix_application
      left: (boolean)
      name: (identifier)
      right: (boolean)))
  expression: (infix_application
    left: (infix_application
      left: (number)
      name: (identifier)
      right: (number))
    name: (identifier)
    right: (number))
  expression: (infix_application
    left: (infix_application
      left: (number)
      name: (identifier)
      right: (number))
    name: (identifier)
    right: (number))
  expression: (infix_application
    left: (number)
    name: (identifier)
    right: (prefix_application
      name: (identifier)
      value: (number)))
  expression: (infix_application
    left: (infix_application
      left: (infix_application
        left: (number)
        name: (identifier)
        right: (number))
      name: (identifier)
      right: (number))
    name: (identifier)
    right: (number))
  expression: (infix_application
    left: (boolean)
    name: (identifier)
    right: (prefix_application
      name: (identifier)
      value: (boolean)))
  expression: (infix_application
    left: (pipeline
      value: (group
        value: (pipeline
          value: (identifier)
          name: (identifier)))
      name: (identifier))
    name: (identifier)
    right: (pipeline
      value: (number)
      name: (group
        value: (pipeline
          value: (identifier)
          name: (identifier))))))

==================
pipeline
==================

a.b.c(1)

---

(program
  expression: (application
    name: (pipeline
      value: (pipeline
        value: (identifier)
        name: (identifier))
      name: (identifier))
    value: (tuple_element
      value: (number))))

==================
access
==================

a[0]
A->b(1)
a.b[c]

---

(program
  expression: (access
      name: (identifier)
      value: (number))
  expression: (application
    name: (access
      name: (parametric_type
        name: (type))
      value: (shorthand_access_identifier))
    value: (tuple_element
      value: (number)))
  expression: (pipeline
    value: (identifier)
    name: (access
      name: (identifier)
      value: (identifier))))

==================
assignment
==================

a :: Type := 1
a := (a :: Type) =>
  1

---

(program
  expression: (assignment
    pattern: (identifier_pattern
      name: (identifier_pattern_name)
      type: (parametric_type
        name: (type)))
    value: (number))
  expression: (assignment
    pattern: (identifier_pattern
      name: (identifier_pattern_name))
    value: (abstraction
      branch: (abstraction_branch
        parameters: (tuple_pattern
          value: (identifier_pattern
            name: (identifier_pattern_name)
            type: (parametric_type
              name: (type))))
        body: (block
          expression: (number))))))

==================
import
==================

import
  a as b,
  c,
  a as b :: Type,
  c :: Type,
  Type as Type,
  Type
from 'source'
import a, b from 'source'

---

(program
  expression: (import
    import: (import_identifier_as
      name: (identifier_pattern_name)
      as: (identifier_pattern
        name: (identifier_pattern_name)))
    import: (identifier_pattern
      name: (identifier_pattern_name))
    import: (import_identifier_as
      name: (identifier_pattern_name)
      as: (identifier_pattern
        name: (identifier_pattern_name)
        type: (parametric_type
          name: (type))))
    import: (identifier_pattern
      name: (identifier_pattern_name)
      type: (parametric_type
        name: (type)))
    import: (import_type_as
      name: (type)
      as: (type))
    import: (type)
    source: (string_pattern))
  expression: (import
    import: (identifier_pattern
      name: (identifier_pattern_name))
    import: (identifier_pattern
      name: (identifier_pattern_name))
    source: (string_pattern)))

==================
external import
==================

export a, b from 'source'

---

(program
  expression: (external_import
    import: (identifier_pattern
      name: (identifier_pattern_name))
    import: (identifier_pattern
      name: (identifier_pattern_name))
    source: (string_pattern)))

==================
export
==================

export a := 1
export module A
  export a := 1

---

(program
  expression: (export
    declaration: (assignment
      pattern: (identifier_pattern
        name: (identifier_pattern_name))
      value: (number)))
  expression: (export
    declaration: (module
      name: (type_declaration
        name: (type))
      body: (block
        expression: (export
          declaration: (assignment
            pattern: (identifier_pattern
              name: (identifier_pattern_name))
            value: (number)))))))

==================
return
==================

return 1
return (a :: Type) =>
  1

---

(program
  expression: (return
    value: (number))
  expression: (return
    value: (abstraction
      branch: (abstraction_branch
        parameters: (tuple_pattern
          value: (identifier_pattern
            name: (identifier_pattern_name)
            type: (parametric_type
              name: (type))))
        body: (block
          expression: (number))))))

==================
if
==================

if false
  1
if true
  1
else
  1
a :=
  if true
    1
  else if false then 1
  else if true
    1

fn(if false then 1)
if true then 1 else 1

---

(program
  expression: (if
    condition: (boolean)
    body: (block
      expression: (number)))
  expression: (if
    condition: (boolean)
    body: (block
      expression: (number))
    else: (block
      expression: (number)))
  expression: (assignment
    pattern: (identifier_pattern
      name: (identifier_pattern_name))
    value: (if
      condition: (boolean)
      body: (block
        expression: (number))
      else_if: (else_if
        condition: (boolean)
        body: (block
          expression: (number)))
      else_if: (else_if
        condition: (boolean)
        body: (block
          expression: (number)))))
  expression: (application
    name: (identifier)
    value: (tuple_element
      value: (if
        condition: (boolean)
        body: (block
          expression: (number)))))
  expression: (if
    condition: (boolean)
    body: (block
      expression: (number))
    else: (block
      expression: (number))))

==================
case
==================

a := case a
     when 1
       1
     else 1

case a
when [1, a :: Type]
  a
when 1, 1 then 1
else 1

---

(program
  expression: (assignment
    pattern: (identifier_pattern
      name: (identifier_pattern_name))
    value: (case
      value: (identifier)
      when: (when
        pattern: (number)
        body: (block
          expression: (number)))
      else: (block
        expression: (number))))
  expression: (case
    value: (identifier)
    when: (when
      pattern: (list_pattern
        element: (number)
        element: (identifier_pattern
          name: (identifier_pattern_name)
          type: (parametric_type
            name: (type))))
      body: (block
        expression: (identifier)))
    when: (when
      pattern: (number)
      pattern: (number)
      body: (block
        expression: (number)))
    else: (block
      expression: (number))))

==================
module
==================

module Type
  a := 1
module Type<a> where a :: a := 1

---

(program
  expression: (module
    name: (type_declaration
      name: (type))
    body: (block
      expression: (assignment
        pattern: (identifier_pattern
          name: (identifier_pattern_name))
        value: (number))))
  expression: (module
    name: (type_declaration
      name: (type)
      parameter: (type_variable))
    body: (block
      expression: (assignment
        pattern: (identifier_pattern
          name: (identifier_pattern_name)
          type: (type_variable))
        value: (number)))))

==================
enum
==================

enum Type
  A
  B = 'string'

---

(program
  expression: (enum
    name: (type)
    value: (enum_value
      name: (type))
    value: (enum_value
      name: (type)
      value: (string))))

==================
interface
==================

interface Type<a>
  a :: a -> Number
  b :: a -> Number
interface Eq<a> => Ord<a>
  compare :: a -> a -> Number

---

(program
  expression: (interface
    name: (type_declaration
      name: (type)
      parameter: (type_variable))
    member: (member_type
      name: (identifier)
      type: (curried_type
        from: (type_variable)
        to: (parametric_type
          name: (type))))
    member: (member_type
      name: (identifier)
      type: (curried_type
        from: (type_variable)
        to: (parametric_type
          name: (type)))))
  expression: (interface
    name: (type_declaration
      dependency: (parametric_type
        name: (type)
        parameter: (type_variable))
      name: (type)
      parameter: (type_variable))
    member: (member_type
      name: (identifier)
      type: (curried_type
        from: (type_variable)
        to: (curried_type
          from: (type_variable)
          to: (parametric_type
            name: (type)))))))

==================
implement
==================

implement Ord<Number>
  compare := 1

---

(program
  expression: (implement
    name: (parametric_type
      name: (type)
      parameter: (parametric_type
        name: (type)))
    assignment: (assignment
      pattern: (identifier_pattern
        name: (identifier_pattern_name))
      value: (number))))

==================
struct declaration
==================

struct Type
  a :: Number
  b :: String

---

(program
  expression: (struct_declaration
    name: (type_declaration
      name: (type))
    member: (member_type
      name: (identifier)
      type: (parametric_type
        name: (type)))
    member: (member_type
      name: (identifier)
      type: (parametric_type
        name: (type)))))

==================
struct
==================

{}
{ a, b }
{ ['a']: 1, ...b, c: 'str', d, e }

---

(program
  expression: (struct)
  expression: (struct
    member: (shorthand_member)
    member: (shorthand_member))
  expression: (struct
    member: (member
      key: (string)
      value: (number))
    member: (spread
      value: (identifier))
    member: (member
      key: (shorthand_access_identifier)
      value: (string))
    member: (shorthand_member)
    member: (shorthand_member)))

==================
named struct
==================

Struct{}
Struct{ a, b }
Struct{ ['a']: 1, ...b, c: 'str', d, e }

---

(program
  expression: (named_struct
    name: (type))
  expression: (named_struct
    name: (type)
    member: (shorthand_member)
    member: (shorthand_member))
  expression: (named_struct
    name: (type)
    member: (member
      key: (string)
      value: (number))
    member: (spread
      value: (identifier))
    member: (member
      key: (shorthand_access_identifier)
      value: (string))
    member: (shorthand_member)
    member: (shorthand_member)))

==================
tuple
==================

()
(a, 1, 'str', ...x)
(1,1)

---

(program
  expression: (tuple)
  expression: (tuple
    value: (tuple_element
      value: (identifier))
    value: (tuple_element
      value: (number))
    value: (tuple_element
      value: (string))
    value: (tuple_element
      value: (spread
      value: (identifier))))
  expression: (tuple
    value: (tuple_element
      value: (number))
    value: (tuple_element
      value: (number))))

==================
named tuple
==================

Tuple()
Tuple(a, 1, 'str', ...x)
Tuple(1,1)
Tuple(1)

---

(program
  expression: (named_tuple
    name: (type))
  expression: (named_tuple
    name: (type)
    value: (tuple_element
      value: (identifier))
    value: (tuple_element
      value: (number))
    value: (tuple_element
      value: (string))
    value: (tuple_element
      value: (spread
      value: (identifier))))
  expression: (named_tuple
    name: (type)
    value: (tuple_element
      value: (number))
    value: (tuple_element
      value: (number)))
  expression: (named_tuple
    name: (type)
    value: (tuple_element
      value: (number))))

==================
list
==================

[]
[a, 1, ...b, 'str']
[1,1..1,1]

---

(program
  expression: (list)
  expression: (list
    element: (identifier)
    element: (number)
    element: (spread
      value: (identifier))
    element: (string))
  expression: (list
    element: (number)
    element: (infix_application
      left: (number)
      name: (identifier)
      right: (number))
    element: (number)))

==================
named list
==================

List[]
List[a, 1, ...b, 'str']
List[1,1..1,1]

---

(program
  expression: (named_list
    name: (type))
  expression: (named_list
    name: (type)
    element: (identifier)
    element: (number)
    element: (spread
      value: (identifier))
    element: (string))
  expression: (named_list
    name: (type)
    element: (number)
    element: (infix_application
      left: (number)
      name: (identifier)
      right: (number))
    element: (number)))

==================
list comprehension
==================

[i * 2 | i in 1..10]
[i / 2 | i in 1..10 if i % 2 == 0]
[[x, y] | x in 1..10 if x % 2 == 0, y in 1..10 if i % 2 == 0]

---

(program
  expression: (list_comprehension
    body: (block
      expression: (infix_application
        left: (identifier)
        name: (identifier)
        right: (number)))
    generator: (generator
      name: (identifier_pattern_name)
      value: (infix_application
        left: (number)
        name: (identifier)
        right: (number))))
  expression: (list_comprehension
    body: (block
      expression: (infix_application
        left: (identifier)
        name: (identifier)
        right: (number)))
    generator: (generator
      name: (identifier_pattern_name)
      value: (infix_application
        left: (number)
        name: (identifier)
        right: (number))
      condition: (infix_application
        left: (infix_application
          left: (identifier)
          name: (identifier)
          right: (number))
        name: (identifier)
        right: (number))))
  expression: (list_comprehension
    body: (block
      expression: (list
        element: (identifier)
        element: (identifier)))
    generator: (generator
      name: (identifier_pattern_name)
      value: (infix_application
        left: (number)
        name: (identifier)
        right: (number))
      condition: (infix_application
        left: (infix_application
          left: (identifier)
          name: (identifier)
          right: (number))
        name: (identifier)
        right: (number)))
    generator: (generator
      name: (identifier_pattern_name)
      value: (infix_application
        left: (number)
        name: (identifier)
        right: (number))
      condition: (infix_application
        left: (infix_application
          left: (identifier)
          name: (identifier)
          right: (number))
        name: (identifier)
        right: (number)))))

==================
type alias
==================

type Type := Type
type Type<a, b> := a -> b

---

(program
  expression: (type_alias
    name: (type_declaration
      name: (type))
    type: (parametric_type
      name: (type)))
  expression: (type_alias
    name: (type_declaration
      name: (type)
      parameter: (type_variable)
      parameter: (type_variable))
    type: (curried_type
      from: (type_variable)
      to: (type_variable))))

==================
type hint
==================

'string' as String

---

(program
  expression: (type_hint
    value: (string)
    type: (parametric_type
      name: (type))))
